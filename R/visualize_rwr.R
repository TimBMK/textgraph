#' Visualize Random Walk Terms
#'
#' @param rwr_terms A random walks result generated by `get_rwr_terms()`
#' @param network A text cooccurrence network, usually generated by
#'   `make_multiplex_objects()`
#' @param group_name String; Name of the grouping variable.
#' @param classification_measure String; name of the measure variable to use for
#'   classification, generated by `get_rwr_terms()`. Must be present in
#'   `walk_terms`. One of "Score", "ScoreMean", "ScoreNorm", "ScoreNormMean",
#'   "ScoreNormGroup", or "ScoreNormGroupMean". See `get_rwr_terms()` for
#'   details.
#' @param n_terms Numerical; number of terms per group to visualize. Picks terms
#'   with the highes `classification_measure` in descending order.
#' @param selection Either "all" to generate an overview plot and plots for all
#'   groups; "overview" to only generate an overview plot; or a character vector
#'   indicating groups to generate an overview plot and group-specific plots
#'   for. Defaults to "all".
#' @param layout The layouting algorithm to use. Defaults to
#'   Fruchterman-Reingold. See `help(ggraph::ggraph())` for options
#' @param ... Additional layouting argument passed on to the algorithm. See
#'   `help(ggraph::ggraph())`
#' @param verbose If TRUE, prints out the plots
#'
#' @return Returns a list of ggraph plots
#' @export
#'
#' @importFrom rlang arg_match
#' @importFrom dplyr "%>%"
#' @importFrom dplyr slice_max filter case_when mutate select rename join_by left_join
#' @importFrom igraph is_igraph graph_from_data_frame set_vertex_attr V induced_subgraph
#' @importFrom ggraph ggraph geom_edge_fan geom_node_point geom_node_text theme_graph
#' @importFrom ggplot2 aes labs scale_color_discrete
#'
#' @examples
#' \dontrun{
#'
#'
#' plots <- visualize_rwr(rwr_terms = rwr_terms,
#'                        network = multiplex_text_network,
#'                        group_name = "ministry_name",
#'                        classification_measure = "ScoreNormMean",
#'                        selection = "all",
#'                        n_terms = 5,
#'                        layout = "fr",
#'                        verbose = F)
#' }
visualize_rwr <- function(rwr_terms,
                          network,
                          group_name,
                          classification_measure = c("Score", "ScoreMean",
                                                     "ScoreNorm",
                                                     "ScoreNormMean",
                                                     "ScoreNormGroup",
                                                     "ScoreNormGroupMean"),
                          n_terms = 5,
                          selection = c("all", "overview", c()),
                          layout = "fr",
                          ...,
                          verbose = TRUE
) {

  # check arguments
  classification_measure <- rlang::arg_match(classification_measure)

  if (!(classification_measure %in% names(rwr_terms))) {
    stop("classification_measure not found in the rwr_terms object\n")
  }

  if (!is.character(selection)) stop("`selection` must be either 'all', 'overview', or a character vector")
  if ("all" %in% selection) selection <- "all"
  if (any(selection != "overview") & any(selection != "all")){
    if (!any(selection %in% rwr_terms[[group_name]])) {
      stop("None of the groups indicated by `selection` are available in the data")}
  }

  if (!is.numeric(n_terms)) stop("n_terms must be numeric\n")

  if ("multiplex" %in% names(network)) { # extract network from the multiplex object
    network <- network$multiplex$network
  }

  if (!igraph::is_igraph(network)) {
    stop("'network' must be an igraph network or multiplex object created by `make_multiplex_objects()`\n")}


  # Extract top terms
  top_terms <- rwr_terms %>%
    dplyr::slice_max(order_by = !!as.name(classification_measure),
                     n = n_terms, by = !!as.name(group_name))

  if (any(selection != "overview") & any(selection != "all")) {
    top_terms <- top_terms %>%
      dplyr::filter(!!as.name(group_name) %in% selection)
  }

  # build and visualize overview network
  overview_network <- top_terms %>%
    dplyr::mutate(NodeNames = dplyr::case_when(seed_term ~ paste0(NodeNames, "*"), # add "*" as seed term indicator
                                               .default = NodeNames)) %>%
    dplyr::select(!!as.name(group_name), NodeNames, !!as.name(classification_measure)) %>%
    dplyr::rename(weight = !!as.name(classification_measure)) %>% # rename as weight so the network is recognized as weigthed by igraph
    igraph::graph_from_data_frame(directed = FALSE)

  overview_network <- igraph::set_vertex_attr( # set additional vertex attribute for visualization
    graph = overview_network,
    name = group_name,
    index = igraph::V(overview_network)[name %in% top_terms[[group_name]]],
    value = igraph::V(overview_network)[name %in% top_terms[[group_name]]]$name
  )

  overview_plot <- overview_network %>%
    ggraph::ggraph(layout = layout, ...) +
    ggraph::geom_edge_fan(ggplot2::aes(edge_alpha = weight)) +
    ggraph::geom_node_point(ggplot2::aes(color = !!as.name(group_name))) +
    ggraph::geom_node_text(ggplot2::aes(label = name,
                                        color = !!as.name(group_name)),
                           repel = TRUE) +
    ggplot2::labs(title = "overview",
                 caption = paste0("Edge Opacity visualizes a term's ",
                                 classification_measure,
                                 "towards ", group_name, ".\n",
                                 "Entities marked with * are seed terms.")) +
    ggplot2::scale_color_discrete(breaks = top_terms[[group_name]]) + # this drops NA by filtering for all values in the top term groups
    ggraph::theme_graph()

  res <- list() # make results object
  res$overview_plot <- overview_plot

  if (verbose) {
    print(overview_plot)
  }

  # group networks
  if (any(selection != "overview")) {
    group_plots <- top_terms %>%
      split(.[[group_name]]) %>%
      purrr::imap(\(group_dat, group)
                  {
                    subgraph <- igraph::induced_subgraph(network,
                                             which(igraph::V(network)$name %in% group_dat$NodeNames),
                                             impl = "create_from_scratch")

                    graph_dat <- data.frame( # data ordered in the same way as the graph
                      NodeNames = igraph::V(subgraph)$name) %>%
                      dplyr::left_join(group_dat, dplyr::join_by(NodeNames))

                    igraph::V(subgraph)$classification_measure <- graph_dat[[classification_measure]] # add classification measure value

                    igraph::V(subgraph)$name <- graph_dat %>%  # add seed term indicator
                      dplyr::mutate(NodeNames = dplyr::case_when(seed_term ~ paste0(NodeNames, "*"),
                                                                 .default = NodeNames)) %>%
                      dplyr::pull(NodeNames)

                    plot <- subgraph %>%
                      ggraph::ggraph(layout = layout, ...) +
                      ggraph::geom_edge_fan(ggplot2::aes(edge_alpha = weight)) +
                      ggraph::geom_node_point(ggplot2::aes(size = classification_measure)) +
                      ggraph::geom_node_text(ggplot2::aes(label = name),
                                             repel = TRUE) +
                      ggplot2::labs(title = group,
                                    caption = paste0("Edge Opacity visualizes the PMI between two terms.\n",
                                                     "Entities marked with * are seed terms."),
                                    size = classification_measure) +
                      ggraph::theme_graph()

                    return(plot)
      })

    # return object and printout
    res <- append(res, group_plots)

    if (verbose) {
      for (plot in group_plots){
        readline(prompt="Press [enter] to show next plot")
        print(plot)
      }
    }
  }
  # final return object
  return(res)
}
